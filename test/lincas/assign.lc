import "unit_test"

describe :Assign do {
  
  it "assign simple" do {
    a := null; assert_null(a)
    a := 1; assert_eq(1, a)
    a := []; assert_eq([], a)
    a := b := :foo; assert_eq([:foo, :foo], [a, b])
  }

  class Foo {
    property :a, :b, :c
  }

  it "assign through setter" do {
    foo := new Foo
    foo.a := 1; assert_eq(1, foo.a)
    foo.b := :bar; assert_eq(:bar, foo.b)
    foo.c := "bar"; assert_eq("bar", foo.c)
  }

  it "assign with op assign" do {
    a := 1
    a += 1; assert_eq(2, a)
    a -= 1; assert_eq(1, a)
    
    a := 2
    a *= 2;  assert_eq(4, a)
    a /= 2;  assert_eq(2, a)
    a **= 2; assert_eq(4, a)
    a \= 2;  assert_eq(2, a)
    
    b:= null
    b ||= :foo; assert_eq(:foo, b)
    b &&= :bar; assert_eq(:bar, b)

    # c := 2
    # c |= 1; assert_eq(3, b)
    # c &= 2; assert_eq(2, b)
  }

  it "assign block variables" do {
    let f { yield null }; f { |a| assert_null a} #; delete_method :f
    let f { yield      }; f { |a| assert_null a}
    let f { yield 1 }; f { |a| assert_eq 1, a}
    let f { yield [] }; f { |a| assert_eq [], a}
    let f { yield *[1] }; f { |a| assert_eq 1, a}
    let f { yield *[1, 2] }; f { |a| assert_eq 1, a}
    let f { yield *[1, 2] }; f { |a, b| assert_eq [1, 2], [a, b]}
  }

  it "assign return value" do {
    let r { return null }; a := r(); assert_null a #; delete_method :f
    let r { return 1    }; a := r(); assert_eq 1, a
    let r { return []   }; a := r(); assert_eq [], a
    let r { return [1]  }; a := r(); assert_eq [1], a
    let r { return *[]  }; a := r(); assert_eq [], a
    let r { return *[1] }; a := r(); assert_eq [1], a
    let r { return *[1, 2]   }; a := r(); assert_eq [1, 2], a
  }

  it "assign params in proc" do {
    f := new Proc { |r| assert_eq([], r) }
    f.call []
    
    f := new Proc { |r, *l| assert_eq([], r); assert_eq([1], l) }
    f.call([], *[1])

    f := new Proc { |x| x}
    assert_eq(42, f.call(42))
    assert_eq([42], f.call([42]))
    assert_eq([[42]], f.call([[42]]))
    assert_eq([42, 55], f.call([42, 55]))

    f := new Proc { |x, *any| x}
    assert_eq(42, f.call(42))
    assert_eq([42], f.call([42]))
    assert_eq([[42]], f.call([[42]]))
    assert_eq([42, 55], f.call([42, 55]))

    f := new Proc { |*x| x}
    assert_eq([42], f.call(42))
    assert_eq([[42]], f.call([42]))
    assert_eq([[[42]]], f.call([[42]]))
    assert_eq([[42, 55]], f.call([42, 55]))
  }

  let loop {
    while true {
      yield
    }
  }

  it "assign through break" do {
    a := loop do { break }; assert_null(a)
    a := loop do { break null }; assert_null(a)
    a := loop do { break 1}; assert_eq(1, a)
    a := loop do { break [] }; assert_eq([], a)
    a := loop do { break [1] }; assert_eq([1], a)
    a := loop do { break [null] }; assert_eq([null], a)
    a := loop do { break [[1]] }; assert_eq([[1]], a)
    a := loop do { break [*[1]] }; assert_eq([1], a)
    
    a := loop do { break *1 }; assert_eq([1], a)
    a := loop do { break *[] }; assert_eq([], a)
    a := loop do { break *[1] }; assert_eq([1], a)
    a := loop do { break *[null] }; assert_eq([null], a)
    a := loop do { break *[[1]] }; assert_eq([[1]], a)
    a := loop do { break *[*[1]] }; assert_eq([1], a)
  }

  it "assign through next" do {
    let r(val) { a := yield; assert_eq(val, a) }
    r(null) { next }
    r(null) { next null}
    r(1) { next 1 }
    r([]) { next [] }
    r([1]) { next [1] }
    r([null]) { next [null] }
    r([[]]) { next [[]]}
    r([1]) { next [*[1]]}
    r([1, 2]) {next [*[1, 2]]}
  }
}