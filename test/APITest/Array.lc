import "unit_test"

describe Array do {

  it "initializes array literal" do {
    a := []
    assert_block("Wrong initialization of array literal") { a.is_a? Array}
    assert_block("Array was expected to be empty"       ) { a.empty?   }
    b := [0]
    assert_block("Array was expected to have 1 element" ) { b.size == 1  }
  }

  it "instantiates array" do  {
    a := new Array(0)
    assert_block("Wrong initialization of array literal" ) { a.is_a? Array}
    assert_block("Array was expected to be empty"        ) { a.empty?   }
    b := new Array(3)
    assert_eq(b.size, 3)
    b.each { |e| assert_eq(e, null) }
  }

  it "::from_range" do {
    ary := Array.from_range 0...4; assert_eq([0, 1, 2, 3], ary)
    ary := Array.from_range 0..4; assert_eq([0, 1, 2, 3, 4], ary)
    ary := Array.from_range 0..2, 0.5; assert_eq([0, 0.5, 1, 1.5, 2], ary)
    x := 1000 ** 10
    assert_raise(NotSupportedError) { Array.from_range 0..x }
  }

  it "#push" do {
    a := []
    a << 12
    a.push 15
    assert_eq([12, 15], a)
  }

  it "#pop" do {
    a := [12, 15]
    r := a.pop
    assert_eq(15, r)
    assert_eq([12], a)
    assert_eq(null, [].pop)
  }

  it "#concat" {
    a := [1, 2, 3]
    a.concat [4, 5, 6]
    assert_eq([1, 2, 3, 4, 5, 6], a)
    assert_raise(TypeError) { a.concat 7 }
  } 

  it "#+" do {
    a := [1, 2, 3]
    b := [4, 5, 6]
    assert_eq([1, 2, 3, 4, 5, 6], a + b)
  }

  it "#[]" do {
    a := [1, 2, 3, 4, 5, 6, 7]
    assert_eq(2, a[1])
    assert_eq([1, 2, 3, 4, 5], a[0..4])
    assert_eq(7, a[-1])
    assert_eq(6, a[-2])
    assert_eq(null, a[7])
    assert_eq(null, a[-8])
  }

  it "#[]=" do {
    a  := [1]
    a[1] := 2; assert_eq([1, 2], a)
    a[0] := 8; assert_eq([8, 2], a)
  }

  it "#include?" do {
    a := [10, "bar", :k]
    assert_true(a.include? 10)
    assert_true(a.include? :k)
  }

  it "#clone" do {
    a := [1,2,3]
    b := a.clone()
    assert_eq(a, b)
    a << "string"
    assert_not_eq(a, b)
  }

  it "#first" do {
    a := ["string", :sym, 12]
    assert_eq("string", a.first)
  }

  it "#last" do {
    a := ["string", :sym, 12]
    assert_eq(12, a.last)
  }

  it "#size" do {
    s := [1,2,3,4]
    assert_eq(4, s.size)
    assert_eq(4, s.length)
  }

  it "#empty?" do {
    assert([].empty?)
    assert_false([1].empty?)
  }

  it "#to_s" do {
    a := [1, 2, 3]
    assert_eq("[1, 2, 3]", a.to_s)
    a << a
    assert_eq("[1, 2, 3, [...]]", a.to_s)
  }

  it "#each" do {
    a := [10,20,30]
    b := a.clone
    i := 0
    a.each do { |v|
      assert_eq(b[i], v)
      i += 1
    }
  }

  it "#map" do {
    b := [1,2,3].map { |v| v * 2}
    assert(b.is_a? Array)
    assert_eq([2,4,6], b)
  }

  it "#map!" do {
    a := [1,2,3]
    a.map! { |v| v * 2 }
    assert(a.is_a? Array)
    assert_eq([2,4,6], a)
  } 

  it "#flatten" do {
    a := [1, [2, [3]]]
    c := a.flatten
    assert(c.is_a? Array)
    assert_eq([1, 2, 3], c)
    a << a
    assert_raise(ArgumentError) { a.flatten }
  }

  it "#insert" do {
    a := [1,2,3]
    b := a.insert(0,0)
    assert(b.is_a? Array)
    assert_eq([0,1,2,3], b)
    b := [1,2,3].insert(1,-1,-2)
    assert(b.is_a? Array)  
    assert_eq([1,-1,-2,2,3], b)
    assert_raise(IndexError) { a.insert a.size + 1, 0 }  
  }

  it "#==" do {
    a := [1,2,3]
    b := [1,2,3]
    assert_true(a == b)
  }

  it "#swap" do {
    a := [2,4,6,8]
    a.swap(1,2)
    assert_eq([2,6,4,8], a)
  }

  it "#sort" do {
    a := [2,6,1,8,9,3,0,4,7,5]
    assert_eq([0,1,2,3,4,5,6,7,8,9], a.sort)
    assert_eq([0,1,2,3,4,5,6,7,8,9], a.sort { |a, b| a < b ? 0 : 1 })
  }

  it "#sort!" do {
    a := [2,6,1,8,9,3,0,4,7,5]
    b := a.clone
    a.sort!; b.sort! { |a, b| a < b ? 0 : 1 }
    assert_eq([0,1,2,3,4,5,6,7,8,9], a)
    assert_eq([0,1,2,3,4,5,6,7,8,9], b)
  }

  it "#max" do {
    a := [3,1,2]
    assert_eq(3, a.max)
  }

  it "#min" do {
    a := [1,3,2]
    assert_eq(1, a.min)
  }

  it "#reverse" do {
    a := [0,1,2,3,4,5,6,7,8,9]
    assert_eq([9,8,7,6,5,4,3,2,1,0], a.reverse)
  }

  it "#reverse!" do {
    a := [0,1,2,3,4,5,6,7,8,9]
    a.reverse!
    assert_eq([9,8,7,6,5,4,3,2,1,0], a)
  }

  it "#shift" do {
    a := [1,2,3,4]
    assert_eq(1, a.shift)
    assert_eq([2,3,4], a)
    assert_eq(2, a.shift)
    assert_eq([3,4], a)
  }

  it "#join" do {
    a := [1,2,3,4]
    assert_eq("1234", a.join)
    assert_eq("1,2,3,4", a.join(","))
    a << a.clone
    assert_eq("12341234", a.join)
    assert_eq("1,2,3,4,1,2,3,4", a.join(","))
    a.last.push([:a,:b,:c])
    assert_eq("12341234:a:b:c", a.join)
    assert_eq("1,2,3,4,1,2,3,4,:a,:b,:c", a.join(","))

    a << a
    assert_raise(ArgumentError) { a.join }
  }

  it "#sort_by" do {
    a := [:b, :n, :k, :c, :a]
    assert_eq([:a, :b, :c, :k, :n], a.sort_by { |v| v.to_s } )
    assert_raise(ArgumentError) { a.sort_by }
  }

  it "#sort_by!" do {
    a := [:b, :n, :k, :c, :a]
    a.sort_by! { |v| v.to_s }
    assert_eq([:a, :b, :c, :k, :n], a)
    assert_raise(ArgumentError) { a.sort_by! }
  }

  it "#delete_at" do {
    a := [1,2,3,4]
    assert_eq(1, a.delete_at(0))
    assert_eq([2,3,4], a)
    assert_eq(3, a.delete_at(1))
    assert_eq([2,4], a)
    assert_eq(4, a.delete_at(1))
    assert_eq([2], a)
    assert_null(a.delete_at a.size + 1)
  }

  it "#each_with_index" do {
    a := [10,20,30]
    b := a.clone
    a.each_with_index do { |v, i|
      assert_eq(b[i], v)
    }
  }

  it "#map_with_index" do {
    a := [10,20,30]
    b := a.map_with_index do { |v, i|
      v + i
    }
    assert_eq([10,21,32], b)
  }

  it "#map_with_index!" do {
    a := [10,20,30]
    a.map_with_index! do { |v, i|
      v + i
    }
    assert_eq([10,21,32], a)
  }

  it "#compact" do {
    a := [1,null,3,null,null,10,:x]
    assert_eq([1,3,10,:x], a.compact)
  }

  it "#compact!" do {
    a := [1,null,3,null,null,10,:x]
    a.compact!
    assert_eq([1,3,10,:x], a)
  }
}